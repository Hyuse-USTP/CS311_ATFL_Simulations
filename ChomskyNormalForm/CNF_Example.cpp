#include <iostream>
#include <vector>
#include <string>
#include <unordered_map>
#include <set>
#include <cctype>
#include <limits>

class CNFGrammar {
private:
    std::unordered_map<std::string, std::vector<std::string>> reverse_rules;
    
    // Helper to store rules for display purposes
    struct DisplayRule { std::string head; std::string body; };
    std::vector<DisplayRule> rules_list;

    bool is_cnf_compliant = true;
    std::string start_symbol;

    bool isVariable(char c) { return std::isupper(c); }
    bool isTerminal(char c) { return std::islower(c); }

public:
    void setStartSymbol(const std::string& s) {
        start_symbol = s;
    }

    void addRule(const std::string& head, const std::string& body) {
        // 1. Store for Parsing (Reverse Lookup)
        reverse_rules[body].push_back(head);
        
        // 2. Store for Display
        rules_list.push_back({head, body});

        // 3. Validate Compliance (CNF Rules)
        // Rule 1: Head must be a single Variable
        if (head.length() != 1 || !isVariable(head[0])) {
            is_cnf_compliant = false;
            std::cerr << "Warning: Rule " << head << " -> " << body << " violates CNF (Head invalid)." << std::endl;
        }
        
        // Rule 2: Body must be either 2 Variables OR 1 Terminal
        bool validBody = false;
        if (body.length() == 2) {
            // A -> BC
            if (isVariable(body[0]) && isVariable(body[1])) validBody = true;
        } else if (body.length() == 1) {
            // A -> a
            if (isTerminal(body[0])) validBody = true;
        }

        if (!validBody) {
            is_cnf_compliant = false;
            std::cerr << "Warning: Rule " << head << " -> " << body << " violates CNF (Body invalid)." << std::endl;
        }
    }

    void printGrammar() {
        std::cout << "Grammar Rules:" << std::endl;
        for (const auto& r : rules_list) {
            std::cout << "  " << r.head << " -> " << r.body << std::endl;
        }
        if (!is_cnf_compliant) {
            std::cout << "  [!] This grammar is NOT in valid Chomsky Normal Form." << std::endl;
        } else {
            std::cout << "  [OK] Valid CNF." << std::endl;
        }
    }

    // CYK Algorithm (Cocke-Younger-Kasami)
    // Determines if 'input' can be generated by the grammar.
    bool parse(const std::string& input) {
        if (!is_cnf_compliant) {
            std::cout << "Error: Cannot parse. Grammar must be in strict CNF." << std::endl;
            return false;
        }
        if (input.empty()) return false; // Simple CYK doesn't handle epsilon

        int n = input.length();
        

        std::vector<std::vector<std::set<std::string>>> table(n + 1, std::vector<std::set<std::string>>(n));

        // Step 1: Initialization (Substrings of Length 1)
        // For each character in input, find variables that produce that terminal.
        for (int i = 0; i < n; i++) {
            std::string terminal(1, input[i]);
            if (reverse_rules.count(terminal)) {
                for (const auto& var : reverse_rules[terminal]) {
                    table[1][i].insert(var);
                }
            }
        }

        // Step 2: Dynamic Programming (Substrings of Length 2 to n)
        for (int len = 2; len <= n; len++) {           // For each length...
            for (int i = 0; i <= n - len; i++) {       // For each start position...
                
                // Try every split point 'k' (1 to len-1)
                // Substring 1: Length k, starts at i
                // Substring 2: Length len-k, starts at i+k
                for (int k = 1; k < len; k++) {
                    
                    const auto& left_vars = table[k][i];             // Variables for first part
                    const auto& right_vars = table[len - k][i + k];  // Variables for second part

                    if (left_vars.empty() || right_vars.empty()) continue;

                    // Cartesian Product: Combine every B from left with every C from right
                    // Check if there is a rule A -> BC
                    for (const auto& B : left_vars) {
                        for (const auto& C : right_vars) {
                            std::string body = B + C; // e.g., "BC"
                            if (reverse_rules.count(body)) {
                                for (const auto& A : reverse_rules[body]) {
                                    table[len][i].insert(A);
                                }
                            }
                        }
                    }
                }
            }
        }

        // Step 3: Acceptance Check
        // Does the cell for the entire string (Length n, Start 0) contain the Start Symbol?
        if (table[n][0].count(start_symbol)) {
            return true;
        }
        return false;
    }
};

int main() {
    std::cout << "--- CNF Simulator with CYK Parser ---" << std::endl;
    std::cout << "Demonstrating a Hash-Map based implementation for efficiency." << std::endl;
    
    // --- Example 1: { a^n b^n } in CNF ---
    // Original CFG: S -> aSb | ab
    // CNF Conversion:
    // S -> AB | AC
    // C -> SB
    // A -> a
    // B -> b
    
    CNFGrammar grammar;
    grammar.setStartSymbol("S");
    grammar.addRule("S", "AB");
    grammar.addRule("S", "AC");
    grammar.addRule("C", "SB");
    grammar.addRule("A", "a");
    grammar.addRule("B", "b");

    grammar.printGrammar();

    std::cout << "\n--- Testing Strings ---" << std::endl;
    std::vector<std::string> tests = {
        "ab",
        "aabb",
        "aaabbb",
        "ba",       // Invalid
        "aabbb",    // Invalid
        "aaabb"     // Invalid
    };

    for (const auto& t : tests) {
        bool result = grammar.parse(t);
        std::cout << "String \"" << t << "\": " << (result ? "ACCEPTED" : "REJECTED") << std::endl;
    }

    // --- Interactive Mode ---
    std::cout << "\n[Interactive Mode]" << std::endl;
    std::cout << "Enter a string to test (or 'exit' to quit): ";
    std::string input;
    while (std::cin >> input && input != "exit") {
        bool result = grammar.parse(input);
        std::cout << "Result: " << (result ? "ACCEPTED" : "REJECTED") << std::endl;
        std::cout << "Enter next string: ";
    }

    return 0;
}

